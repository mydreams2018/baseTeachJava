Java 8 新特性--Lambda表达式作为方法参数 
简单来说,可以看成是对匿名内部类的缩写,首先前提是方法参数 是一个函数式接口

根据上述语法规则,以下哪个不是有效的Lambda表达式？
(1) () -> {}
(2) () -> "Raoul"
(3) () -> {return "Mario";}
(4) (Integer i) -> return "Alan" + i;
(5) (String s) -> {"IronMan";}
答案：只有4和5是无效的Lambda.
(1) 这个Lambda没有参数,并返回void.它类似于主体为空的方法：public void run() {}.
(2) 这个Lambda没有参数,并返回String作为表达式.
(3) 这个Lambda没有参数,并返回String（利用显式返回语句）.
(4) return是一个控制流语句.要使此Lambda有效,需要使花括号,如下所示：
    (Integer i) -> {return "Alan" + i;}.
(5)“Iron Man”是一个表达式,不是一个语句.要使此Lambda有效,你可以去除花括号
    和分号,如下所示：(String s) -> "Iron Man".或者如果你喜欢,可以使用显式返回语
    句,如下所示：(String s)->{return "IronMan";}

方法引用
对象::方法
类::方法
Supplier<Apple> c1 = Apple::new;
Apple a1 = c1.get();
这就等价于：
Supplier<Apple> c1 = () -> new Apple();
Apple a1 = c1.get()

Function<Integer, Apple> c2 = Apple::new;
Apple a2 = c2.apply(110);
这就等价于：
Function<Integer, Apple> c2 = (weight) -> new Apple(weight);
Apple a2 = c2.apply(110);

BiFunction<String, Integer, Apple> c3 = Apple::new;
Apple c3 = c3.apply("green", 110);
这就等价于：
BiFunction<String, Integer, Apple> c3 =
 (color, weight) -> new Apple(color, weight);
Apple c3 = c3.apply("green", 110);

    局部变量 final 例:a (b=a访问的是b副本、如果局部变量有修改、多线程的情况下可能访问到旧的数据,造成数据脏读)
    实例变量和局部变量背后的实现有一个关键不同.实例变量都存储在堆中,而局部变量则保存在栈上.
    如果Lambda可以直接访问局部变量,而且Lambda是在另一个线程中使用的,则使用Lambda的线程,
    可能会在分配该变量的线程将这个变量收回之后,去访问该变量.
    因此,Java在访问自由局部变量时,实际上是在访问它的副本,而不是访问原始变量.如果局部变量仅仅赋值一次那就没有什么区别了

    闭包
    你可能已经听说过闭包（closure，不要和Clojure编程语言混淆）这个词，你可能会想
    Lambda是否满足闭包的定义。用科学的说法来说，闭包就是一个函数的实例，且它可以无限
    制地访问那个函数的非本地变量。例如，闭包可以作为参数传递给另一个函数。它也可以访
    问和修改其作用域之外的变量。现在，Java 8的Lambda和匿名类可以做类似于闭包的事情：
    它们可以作为参数传递给方法，并且可以访问其作用域之外的变量。但有一个限制：它们不
    能修改定义Lambda的方法的局部变量的内容。这些局部变量必须是隐式最终的。
    如前所述，这种限制存在的原因在于局部变量保存在栈上，
    并且隐式表示它们仅限于其所在线程。如果允许捕获可改变的局部变量，就会引发造成线程
    不安全的新的可能性，而这是我们不想看到的
    （实例变量可以，因为它们保存在堆中，而堆是在线程之间共享的）

interface A,B 都有 default fun()默认方法
class C implements A,B  实现方法重名有多个
在class C中可以使用 A.super.fun() 指定接口的默认方法